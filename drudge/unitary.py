"""
Drudge for reduced AGP - PBCS Hamiltonian.
"""
import collections, functools, operator

from sympy import Integer, Symbol, IndexedBase, KroneckerDelta, factorial
from sympy.utilities.iterables import default_sort_key

from drudge import Tensor
from drudge import PartHoleDrudge, SpinOneHalfPartHoleDrudge
from agp import *
from drudge.canon import IDENT,NEG
from drudge.canonpy import Perm
from drudge.term import Vec, Range, Term
from drudge.utils import sympy_key
from drudge.genquad import GenQuadDrudge


class UnitaryGroupDrudge(GenQuadDrudge):
    r"""Drudge for projected BCS approach in pairing Hamiltonian.

    The reduced BCS drudge contains utilities for solving problems around the
    reduced BCS Hamiltonian, or pairing Hamiltonian.  In this problem, we have
    an :math:`\mathfrak{su}(2)`-like algebra generated by subscriptable
    generators :math:`N`, :math:`P`, and :math:`P^\dag`, which satisfies the
    commutations rules

    .. math::

        [N_p, P_q^\dag] & = 2 \delta_{pq} P_q^\dag \\
        [N_p, P_q] &= -2 \delta_{pq} P_q \\
        [P_p, P_q^\dag] &= \delta_{pq} \left( 1 - N_p \right) \\

    where the symbols :math:`p` and :math:`q` can be over two disjoint ranges,
    the particle range and the hole range.  The usage of these two ranges, as
    well as their default symbols, are exactly the same as those in the
    :py:class:`PartHoleDrudge`.

    In addition to the commutation rules, this drudge also has a Hamiltonian
    stored as ``ham`` attribute, which reads

    .. math::

        \epsilon_p N_p + G_{p, q} P^\dag_p P_q

    where :math:`p` and :math:`q` are summed over the two ranges.

    """

    DEFAULT_GEN = Vec('E')

    def __init__(
            self, ctx,
            part_range=Range('V', 0, Symbol('nv')),
            part_dumms=PartHoleDrudge.DEFAULT_PART_DUMMS,
            hole_range=Range('O', 0, Symbol('no')),
            hole_dumms=PartHoleDrudge.DEFAULT_HOLE_DUMMS,
            all_orb_dumms=PartHoleDrudge.DEFAULT_ORB_DUMMS,
            energies=IndexedBase(r'\epsilon'), interact=IndexedBase('G'),
            ug_gen=DEFAULT_GEN,
            **kwargs
    ):
        """Initialize the drudge object."""

        # Initialize the base su2 problem.
        super().__init__(ctx, **kwargs)

        # Set the range and dummies.
        self.part_range = part_range
        self.hole_range = hole_range
        self.set_dumms(part_range, part_dumms)
        self.set_dumms(hole_range, hole_dumms)
        self.add_resolver_for_dumms()

        self.all_orb_dumms = tuple(all_orb_dumms)
        self.set_name(*self.all_orb_dumms)
        self.add_resolver({
            i: (self.part_range, self.hole_range) for i in all_orb_dumms
        })

        # Set the operator attributes

        self.ug_gen = ug_gen

        # Make additional name definition for the operators.
        self.set_name(**{
            ug_gen.label[0]+'_':ug_gen,
        })

        self.set_name(ug_gen)
        
        # Defining spec for passing to an external function - the Swapper
        spec = _UGSpec(
                ug_gen=ug_gen,
        )

        self._spec = spec
        
        # Create an instance of the ProjectedBCS or AGP Drudge to map from E_pq
        # to D_dag, N, D so that normal ordering and vev evaluation can be done
        agp_dr = ProjectedBCSDrudge(
            ctx, part_range, part_dumms,
            hole_range, hole_dumms
        )
        self._agp_dr = agp_dr

        # Mapping to D_dag, N, D
        D_p = agp_dr.raise_
        N_ = agp_dr.cartan
        D_m = agp_dr.lower
        sig = agp_dr.sig
        zpar = agp_dr.zpar

        gen_idx1, gen_idx2 = self.all_orb_dumms[:2]

        epq_def = self.define(
            ug_gen,gen_idx1,gen_idx2,
            sig[gen_idx1,gen_idx2]*( zpar[gen_idx1]*D_m[gen_idx1,gen_idx2] + \
                zpar[gen_idx2]*D_p[gen_idx1,gen_idx2] ) + \
                KroneckerDelta(gen_idx1,gen_idx2)*N_[gen_idx1]
        )

        self._defs = [
            epq_def
        ]

        # set the Swapper
        self._swapper = functools.partial(_swap_ug, spec=spec)

    @property
    def swapper(self) -> GenQuadDrudge.Swapper:
        """Swapper for the new AGP Algebra."""
        return self._swapper

    def _transl2agp(self, tensor: Tensor):
        """Translate a tensor object in terms of the fermion operators.

        This is an internally utility.  The resulted tensor has the internal
        fermion drudge object as its owner.
        """
        return Tensor(
            self._agp_dr,
            tensor.subst_all(self._defs).terms
        )
    def get_vev(self,h_tsr: Tensor, Ntot: Symbol):
        """Function to evaluate the expectation value of a normal
        ordered tensor 'h_tsr' with respect to the projected BCS
        ground state. This can be done after translating the the
        unitary group terms into the AGP basis algebra.
            h_tsr = tensor whose VEV is to be evaluated
            Ntot = total number of orbitals available
        """
        transled = self._transl2agp(h_tsr)
        transled = self._agp_dr.agp_simplify(transled,final_step=True)
        res = self._agp_dr.get_vev(transled,Ntot)
        return Tensor(self, res.terms)


_UGSpec = collections.namedtuple('_UGSpec',[
    'ug_gen'
])


def _swap_ug(vec1: Vec, vec2: Vec, depth=None, *,spec: _UGSpec):
    """Swap two vectors based on the commutation rules for Unitary Group generators.
    Here, we introduce an additional input parameter 'depth' which is never
    specified by the user. Rather, it is put to make use os the anti-symmetric 
    nature of the commutation relations and make the function def compact. 
    """
    if depth is None:
        depth = 1
    
    char1, indice1, key1 = _parse_vec(vec1,spec)
    char2, indice2, key2 = _parse_vec(vec2,spec)
    
    p = indice1[0]
    q = indice1[1]
    r = indice2[0]
    s = indice2[1]

    if p != r:
        if p is min(p,r,key=default_sort_key):
            return None
        elif r is min(p,r,key=default_sort_key):
            expr = KroneckerDelta(q,r)*spec.ug_gen[p,s] - KroneckerDelta(p,s)*spec.ug_gen[r,q]
            return _UNITY, expr
        else:
            return None
    elif p == r:
        if q is min(q,s,key=default_sort_key):
            return None
        elif s is min(q,s,key=default_sort_key):
            expr = KroneckerDelta(q,r)*spec.ug_gen[p,s] - KroneckerDelta(p,s)*spec.ug_gen[r,q]
            return _UNITY, expr
        else:
            return None
    else:
        assert False



_UG_GEN = 0

_UNITY = Integer(1)
_NOUGHT = Integer(0)
_TWO = Integer(2)

def _parse_vec(vec, spec: _UGSpec):
    """Get the character, lattice indices, and the indices of keys of vector.
    """
    base = vec.base
    if base == spec.ug_gen:
        char = _UG_GEN
    else:
        raise ValueError('Unexpected generator of the Unitary Group',vec)
    
    indices = vec.indices
    if len(indices)!=2:
        raise ValueError('Unexpected length of indices for the generators of Unitary Group',vec)
    keys = tuple(sympy_key(i) for i in indices)

    return char, indices, keys
