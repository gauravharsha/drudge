"""
Drudge for reduced AGP - PBCS Hamiltonian.
"""
import collections, functools, operator

from sympy import Integer, Symbol, IndexedBase, KroneckerDelta, factorial
from sympy.utilities.iterables import (has_dups, default_sort_key)

from drudge import Tensor
from drudge.fock import PartHoleDrudge, SpinOneHalfPartHoleDrudge
from drudge.canon import IDENT
from drudge.canonpy import Perm
from drudge.term import Vec, Range, Term
from drudge.utils import sympy_key
from drudge.genquad import GenQuadDrudge


class ProjectedBCSDrudge(GenQuadDrudge):
    r"""Drudge for projected BCS approach in pairing Hamiltonian.

    The reduced BCS drudge contains utilities for solving problems around the
    reduced BCS Hamiltonian, or pairing Hamiltonian.  In this problem, we have
    an :math:`\mathfrak{su}(2)`-like algebra generated by subscriptable
    generators :math:`N`, :math:`P`, and :math:`P^\dag`, which satisfies the
    commutations rules

    .. math::

        [N_p, P_q^\dag] & = 2 \delta_{pq} P_q^\dag \\
        [N_p, P_q] &= -2 \delta_{pq} P_q \\
        [P_p, P_q^\dag] &= \delta_{pq} \left( 1 - N_p \right) \\

    where the symbols :math:`p` and :math:`q` can be over two disjoint ranges,
    the particle range and the hole range.  The usage of these two ranges, as
    well as their default symbols, are exactly the same as those in the
    :py:class:`PartHoleDrudge`.

    In addition to the commutation rules, this drudge also has a Hamiltonian
    stored as ``ham`` attribute, which reads

    .. math::

        \epsilon_p N_p + G_{p, q} P^\dag_p P_q

    where :math:`p` and :math:`q` are summed over the two ranges.

    """

    DEFAULT_CARTAN = Vec('N')
    DEFAULT_RAISE = Vec(r'D^\dagger')
    DEFAULT_LOWER = Vec('D')

    def __init__(
            self, ctx,
            part_range=Range('V', 0, Symbol('nv')),
            part_dumms=PartHoleDrudge.DEFAULT_PART_DUMMS,
            hole_range=Range('O', 0, Symbol('no')),
            hole_dumms=PartHoleDrudge.DEFAULT_HOLE_DUMMS,
            all_orb_dumms=PartHoleDrudge.DEFAULT_ORB_DUMMS,
            upar=IndexedBase('u'), vpar=IndexedBase('v'),
            zpar=IndexedBase('z'), sig=IndexedBase(r'\sigma'),
            energies=IndexedBase('epsilon'), interact=IndexedBase('G'),
            cartan=DEFAULT_CARTAN, raise_=DEFAULT_RAISE, lower=DEFAULT_LOWER,
            **kwargs
    ):
        """Initialize the drudge object."""

        # Initialize the base su2 problem.
        super().__init__(ctx, **kwargs)

        # Set the range and dummies.
        self.part_range = part_range
        self.hole_range = hole_range
        self.set_dumms(part_range, part_dumms)
        self.set_dumms(hole_range, hole_dumms)
        self.add_resolver_for_dumms()

        self.all_orb_dumms = tuple(all_orb_dumms)
        self.set_name(*self.all_orb_dumms)
        self.add_resolver({
            i: (self.part_range, self.hole_range) for i in all_orb_dumms
        })

        self.cartan = cartan
        self.raise_ = raise_
        self.lower = lower

        self.upar = upar
        self.vpar = vpar
        self.zpar = zpar

        # Make additional name definition for the operators.
        self.set_name(**{
            cartan.label[0]+'_':cartan,
            raise_.label[0]+'_p':raise_,
            lower.label[0]+'_m':lower
        })

        self.set_name(cartan, lower, Ddag=raise_)
        spec = _AGPSpec(
                cartan=cartan,raise_=raise_,lower=lower,
                upar=upar,vpar=vpar,sig=sig
        )

        self.set_symm(sig,
            Perm([1,0],IDENT),
            valence=2
        )
        self._spec = spec

        self._swapper = functools.partial(_swap_agp, spec=spec)

        # Define the Hamiltonian.
        # gen_idx, gen_idx2 = self.all_orb_dumms[:2]
        # ham = self.einst(
        #     energies[gen_idx] * cartan[gen_idx] +
        #     interact[gen_idx, gen_idx2] * raise_[gen_idx] * lower[gen_idx2]
        # )
        # self.ham = ham.simplify()

        # Set additional tensor methods.
        # self.set_tensor_method('eval_vev', self.eval_vev)

    @property
    def swapper(self) -> GenQuadDrudge.Swapper:
        """Swapper for the new AGP Algebra."""
        return self._swapper

    def get_vev(self,h_tsr: Tensor, Ntot: Symbol, Npart: Symbol):
        """Function to evaluate the expectation value of a normal
        ordered tensor 'h_tsr' with respect to the projected BCS
        ground state
            h_tsr = tensor whose VEV is to be evaluated
            Ntot = total number of orbitals available
            Npart = Number of particles
        """
        ctan = self.cartan
        

        def vev_of_term(term):
            """Return the VEV of a given term"""
            vecs = term.vecs
            t_amp = term.amp
            for i in vecs:
                if i.base==ctan:
                    t_amp = t_amp*self.zpar[i.indices]*self.zpar[i.indices]
                else:
                    return []
            lk = len(vecs)
            t_amp = t_amp*factorial(Ntot - lk)/factorial(Ntot)*(2**lk)
            return [Term(sums=term.sums, amp = t_amp, vecs=())]
        return h_tsr.bind(vev_of_term)

    #
    # Additional customization of the simplification
    #

    # def normal_order(self, terms, **kwargs):
    #     """Take the operators into normal order.

    #     Here, in addition to the common normal-ordering operation, we remove any
    #     term with a cartan operator followed by an lowering operator with the
    #     same index, and any term with a raising operator followed by a cartan
    #     operator with the same index.

    #     """

    #     noed = super().normal_order(terms, **kwargs)
    #     return noed.filter(functools.partial(
    #         _nonzero_by_cartan,
    #         raise_=self.raise_, cartan=self.cartan, lower=self.lower
    #     ))

    #
    # Vacuum expectation value
    #

# def _nonzero_by_cartan(term: Term, raise_, cartan, lower):
#     """If the term is zero because of the cartan in it."""
# 
#     raise_indices = set()
#     cartan_indices = set()
# 
#     for vec in term.vecs:
#         base = vec.base
#         indices = vec.indices
# 
#         if base == raise_:
#             raise_indices.add(indices)
#         elif base == cartan:
#             if indices in raise_indices:
#                 return False
#             cartan_indices.add(indices)
#         elif base == lower:
#             if indices in cartan_indices:
#                 return False
# 
#         continue
# 
#     return True

_AGPSpec = collections.namedtuple('_AGPSpec',[
    'cartan',
    'raise_',
    'lower',
    'upar',
    'vpar',
    'sig'
])


def _swap_agp(vec1: Vec, vec2: Vec, depth=None, *,spec: _AGPSpec):
    """Swap two vectors based on the AGP operators commutation rules
    Here, we introduce an additional input parameter 'depth' which is never
    specified by the user. Rather, it is put to make use os the anti-symmetric 
    nature of the commutation relations and make the function def compact. 
    """
    if depth is None:
        depth = 1
    
    char1, indice1, key1 = _parse_vec(vec1,spec)
    char2, indice2, key2 = _parse_vec(vec2,spec)
    
    isCartan1 = (char1==1) and (len(indice1)==1)
    isCartan2 = (char2==1) and (len(indice2)==1)

    notCartan1 = (char1!=1) and (len(indice1)==2)
    notCartan2 = (char2!=1) and (len(indice2)==2)

    if not((isCartan1 or notCartan1) and (isCartan2 or notCartan2)):
        raise ValueError(
            'Invalid AGP generators on lattice', (vec1, vec2),
            'Inappropriate rank of indices with the input operator'
        )

    vpar = spec.vpar
    upar = spec.upar
    sig = spec.sig

    if char1 == _RAISE:
    
        return None
    
    elif char1 == _CARTAN:

        r = indice1[0]

        if char2 == _RAISE:
            p = indice2[0]
            q = indice2[1]
            if p==q:
                return [],[]
            del_rq = KroneckerDelta(r,q)
            del_rp = KroneckerDelta(r,p)
            expr1 = (del_rq*(1-del_rp))*sig[r,p]*(
                    ( (vpar[r]*upar[p])**2 + (vpar[p]*upar[r])**2 )*spec.raise_[r,p]
                    + 2*vpar[r]*vpar[p]*upar[r]*upar[p]*spec.lower[r,p]
            )
            expr2 = (del_rp*(1-del_rq))*sig[r,q]*(
                    ( (vpar[r]*upar[q])**2 + (vpar[q]*upar[r])**2 )*spec.raise_[r,q]
                    + 2*vpar[r]*vpar[q]*upar[r]*upar[q]*spec.lower[r,q]
            )

            return _UNITY, expr1 - expr2
        
        else:

            return None

    elif char1 == _LOWER:

        p = indice1[0]
        q = indice1[1]
        if p==q:
            return [],[]

        if char2 == _RAISE:
            r = indice2[0]
            s = indice2[1]
            if r==s:
                return [],[]
            del_pr = KroneckerDelta(p,r)
            del_qs = KroneckerDelta(q,s)
            del_ps = KroneckerDelta(p,s)
            del_qr = KroneckerDelta(q,r)
            
            def D_Ddag_comm_expr(a,b,c,d):
                del_ac = KroneckerDelta(a,c)
                del_bd = KroneckerDelta(b,d)
                exprn = del_bd*(1-del_ac)*sig[a,c]*( (vpar[c]*upar[c])*(
                    (vpar[a]*upar[b])**2 - (vpar[b]*upar[a])**2 )*spec.lower[a,c] +
                    (vpar[a]*upar[a])*(
                        (vpar[c]*upar[b])**2 - (vpar[b]*upar[c])**2)*(
                            spec.raise_[a,c]
                        )
                    ) 
                return exprn
            expr1 = ((vpar[p]*upar[q])**2 - (vpar[q]*upar[p])**2)*(
                del_pr*del_qs - del_qr*del_ps)*(spec.cartan[p] - spec.cartan[q])
            expr2 = D_Ddag_comm_expr(p,q,r,s)
            expr3 = D_Ddag_comm_expr(q,p,s,r)
            expr4 = -D_Ddag_comm_expr(p,q,s,r)
            expr5 = -D_Ddag_comm_expr(q,p,r,s)

            tot_comm = expr1 + expr2 + expr3 + expr4

            return _UNITY, tot_comm

        elif char2 == _CARTAN:
            r = indice2[0]
            del_rp = KroneckerDelta(r,p)
            del_rq = KroneckerDelta(r,q)
            expr1 = (del_rq*(1-del_rp))*sig[r,p]*(
                    ( (vpar[r]*upar[p])**2 + (vpar[p]*upar[r])**2 )*spec.lower[r,p]
                    + 2*vpar[r]*vpar[p]*upar[r]*upar[p]*spec.raise_[r,p]
            )
            expr2 = (del_rp*(1-del_rq))*sig[r,q]*(
                    ( (vpar[r]*upar[q])**2 + (vpar[q]*upar[r])**2 )*spec.lower[r,q]
                    + 2*vpar[r]*vpar[q]*upar[r]*upar[q]*spec.raise_[r,q]
            )
            
            return _UNITY, expr1 - expr2

        else:

            return None

    else:
        assert False


_RAISE = 0
_CARTAN = 1
_LOWER = 2

_UNITY = 1
_ZERO = 0

def _parse_vec(vec, spec: _AGPSpec):
    """Get the character, lattice indices, and the indices of keys of vector.
    """
    base = vec.base
    if base == spec.cartan:
        char = _CARTAN
    elif base == spec.raise_:
        char = _RAISE
    elif base == spec.lower:
        char = _LOWER
    else:
        raise ValueError('Unexpected vector for the AGP algebra',vec)
    
    indices = vec.indices
    keys = tuple(sympy_key(i) for i in indices)

    return char, indices, keys
